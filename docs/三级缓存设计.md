# 三级缓存设计文档

## 1. 概述

本项目实现了一个基于 Kratos 框架的多级缓存服务，采用 **Local (Ristretto) → Redis → MySQL** 三级缓存架构，提供高性能、高可用的缓存解决方案。

### 1.1 设计目标

- **高性能**: 本地缓存提供微秒级访问延迟
- **高可用**: 多级缓存保证数据可靠性
- **可扩展**: 支持水平扩展，多实例部署
- **数据一致性**: 通过缓存回填机制保证数据一致

### 1.2 适用场景

- 高频读取、低频写入的数据
- 需要持久化的配置信息
- API 密钥、Token 等敏感数据的缓存

---

## 2. 架构设计

### 2.1 整体架构

```
┌─────────────────────────────────────────────────────────────────┐
│                           客户端请求                              │
└─────────────────────────────────────────────────────────────────┘
                                │
                                ▼
┌─────────────────────────────────────────────────────────────────┐
│                        CacheServer (gRPC)                        │
│                                                                  │
│  ┌──────────────┐    ┌──────────────┐    ┌──────────────┐      │
│  │     Set      │    │     Get      │    │     Del      │      │
│  └──────────────┘    └──────────────┘    └──────────────┘      │
└─────────────────────────────────────────────────────────────────┘
                                │
                                ▼
┌─────────────────────────────────────────────────────────────────┐
│                         ChainCache                               │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  Level 1: Ristretto (本地内存缓存)                        │   │
│  │  - 访问延迟: ~1μs                                         │   │
│  │  - 容量: 1MB (可配置)                                     │   │
│  │  - 特点: 进程内缓存，最快访问速度                           │   │
│  └─────────────────────────────────────────────────────────┘   │
│                              │                                   │
│                              ▼ (L1 未命中)                       │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  Level 2: Redis (分布式缓存)                              │   │
│  │  - 访问延迟: ~1ms                                         │   │
│  │  - 容量: 取决于 Redis 配置                                 │   │
│  │  - 特点: 跨实例共享，支持 TTL                              │   │
│  └─────────────────────────────────────────────────────────┘   │
│                              │                                   │
│                              ▼ (L2 未命中)                       │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  Level 3: MySQL (持久化存储)                              │   │
│  │  - 访问延迟: ~10ms                                        │   │
│  │  - 容量: 取决于磁盘空间                                    │   │
│  │  - 特点: 数据持久化，不丢失                                │   │
│  └─────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────┘
```

### 2.2 缓存层级说明

| 层级 | 存储类型 | 访问延迟 | 容量 | 特点 |
|------|----------|----------|------|------|
| L1 | Ristretto | ~1μs | 1MB | 本地内存，最快 |
| L2 | Redis | ~1ms | GB级 | 分布式，跨实例共享 |
| L3 | MySQL | ~10ms | TB级 | 持久化，数据不丢失 |

---

## 3. 核心组件

### 3.1 ChainCache

`ChainCache` 是三级缓存的核心实现，负责协调各层缓存的读写操作。

```go
type ChainCache[T any] struct {
    caches     []*cacheWrapper[T]  // 缓存链
    setChannel chan *chainKeyValue[T]  // 异步回填通道
}
```

#### 关键特性

1. **泛型支持**: 使用 Go 1.18+ 泛型，支持任意类型数据
2. **链式结构**: 缓存按顺序组织，支持任意层级
3. **异步回填**: 通过 channel 实现非阻塞回填

### 3.2 Store 接口

所有存储后端都实现统一的 `Store` 接口：

```go
type Store interface {
    Get(ctx context.Context, key any) (any, error)
    GetWithTTL(ctx context.Context, key any) (any, time.Duration, error)
    Set(ctx context.Context, key any, value any) error
    SetWithTTL(ctx context.Context, key any, value any, ttl time.Duration) error
    Del(ctx context.Context, key any) error
    Clear(ctx context.Context) error
    Wait(ctx context.Context)
}
```

### 3.3 DelegateCache

`DelegateCache` 将 `Store` 接口适配为 `Cache` 接口：

```go
type DelegateCache[T any] struct {
    store store.Store
}

func New[T any](store store.Store) *DelegateCache[T] {
    return &DelegateCache[T]{store: store}
}
```

---

## 4. 读写流程

### 4.1 写入流程 (Set)

写入时，数据会**同时写入所有缓存层**，保证数据一致性：

```
┌──────────┐
│  Client  │
└────┬─────┘
     │ Set(key, value)
     ▼
┌──────────┐     ┌──────────┐     ┌──────────┐
│    L1    │ ──▶ │    L2    │ ──▶ │    L3    │
│ Ristretto│     │  Redis   │     │  MySQL   │
└──────────┘     └──────────┘     └──────────┘
     │                │                │
     ▼                ▼                ▼
   写入成功         写入成功         写入成功
```

**代码实现**:

```go
func (c *ChainCache[T]) Set(ctx context.Context, key any, obj T) error {
    var errs []error
    for _, cache := range c.caches {
        if err := cache.Set(ctx, key, obj); err != nil {
            errs = append(errs, err)
        }
    }
    return errors.Join(errs...)
}
```

### 4.2 读取流程 (Get)

读取时，从 L1 开始**逐层查找**，命中后立即返回并**异步回填**上层缓存：

```
┌──────────┐
│  Client  │
└────┬─────┘
     │ Get(key)
     ▼
┌──────────┐
│    L1    │ ◀─── 命中? ───▶ 返回数据
│ Ristretto│      │
└──────────┘      │ 未命中
                  ▼
            ┌──────────┐
            │    L2    │ ◀─── 命中? ───▶ 返回数据 + 异步回填 L1
            │  Redis   │      │
            └──────────┘      │ 未命中
                              ▼
                        ┌──────────┐
                        │    L3    │ ◀─── 命中? ───▶ 返回数据 + 异步回填 L1, L2
                        │  MySQL   │      │
                        └──────────┘      │ 未命中
                                          ▼
                                      返回错误
```

**代码实现**:

```go
func (c *ChainCache[T]) GetWithTTL(ctx context.Context, key any) (T, time.Duration, error) {
    for _, cache := range c.caches {
        obj, ttl, err := cache.GetWithTTL(ctx, key)
        if err == nil {
            // 命中后，异步回填到上层缓存
            c.setChannel <- &chainKeyValue[T]{key, obj, ttl, cache.id}
            return obj, ttl, nil
        }
    }
    return *new(T), 0, ErrKeyNotFound
}
```

### 4.3 异步回填机制

回填通过独立的 goroutine 异步执行，不阻塞主请求：

```go
func (c *ChainCache[T]) Sync() {
    for item := range c.setChannel {
        for _, cache := range c.caches {
            // 回填到命中层之前的所有缓存
            if item.id == cache.id {
                break
            }
            cache.SetWithTTL(context.Background(), item.key, item.value, item.ttl)
        }
    }
}
```

**回填示例**:

```
场景: 数据在 L3 (MySQL) 命中

1. Get(key) → L1 miss → L2 miss → L3 hit
2. 返回数据给客户端
3. 异步: 将数据回填到 L1 和 L2
4. 下次请求: L1 命中，直接返回
```

### 4.4 删除流程 (Del)

删除时，从**所有缓存层**删除数据：

```go
func (c *ChainCache[T]) Del(ctx context.Context, key any) error {
    for _, cache := range c.caches {
        cache.Del(ctx, key)
    }
    return nil
}
```

---

## 5. 缓存策略

### 5.1 命名空间缓存 (两级)

用于通用的键值缓存，使用 **L1 + L2** 两级缓存：

```
Namespaced Cache: Ristretto → Redis
```

**Key 格式**: `namespace:{namespace}:{key}`

**示例**:
```
namespace:user:123 → {"name": "张三", "age": 25}
namespace:config:app → {"version": "1.0.0"}
```

### 5.2 Secret 缓存 (三级)

用于密钥等需要持久化的数据，使用 **L1 + L2 + L3** 三级缓存：

```
Secret Cache: Ristretto → Redis → MySQL
```

**数据模型**:
```go
type SecretM struct {
    ID          int64
    UserID      string
    Name        string
    SecretID    string    // 缓存 Key
    SecretKey   string
    Expires     int64
    Status      int32
    Description string
    CreatedAt   time.Time
    UpdatedAt   time.Time
}
```

---

## 6. 配置说明

### 6.1 Ristretto 配置

```go
localCache, _ := ristretto.NewCache(&ristretto.Config{
    NumCounters: 10000,   // 跟踪频率的 key 数量
    MaxCost:     1 << 20, // 最大缓存大小 (1MB)
    BufferItems: 64,      // Get 缓冲区大小
})
```

| 参数 | 说明 | 建议值 |
|------|------|--------|
| NumCounters | 跟踪频率的 key 数量 | 预期 key 数量的 10 倍 |
| MaxCost | 最大缓存成本 | 根据内存大小设置 |
| BufferItems | Get 缓冲区 | 64 |

### 6.2 Redis 配置

```yaml
redis:
  addr: 127.0.0.1:6379
  read_timeout: 0.2s
  write_timeout: 0.2s
```

### 6.3 MySQL 配置

```yaml
database:
  driver: mysql
  source: root:root@tcp(127.0.0.1:3306)/cacheserver?parseTime=True&loc=Local
```

---

## 7. 性能优化

### 7.1 本地缓存优化

1. **合理设置 MaxCost**: 根据服务器内存大小设置
2. **热点数据预热**: 服务启动时预加载热点数据
3. **避免大对象**: 大对象会占用过多缓存空间

### 7.2 Redis 优化

1. **连接池**: 使用连接池减少连接开销
2. **Pipeline**: 批量操作使用 Pipeline
3. **合理设置 TTL**: 避免缓存雪崩

### 7.3 回填优化

1. **Channel 缓冲**: 使用带缓冲的 channel 避免阻塞
2. **批量回填**: 可扩展为批量回填减少网络开销
3. **回填限流**: 避免回填风暴

---

## 8. 故障处理

### 8.1 L1 故障

- **影响**: 本地缓存失效，请求直接访问 L2
- **恢复**: 服务重启后自动恢复

### 8.2 L2 (Redis) 故障

- **影响**: 分布式缓存失效，请求访问 L3
- **恢复**: Redis 恢复后，通过回填机制自动恢复
- **降级**: 可配置跳过 L2 直接访问 L3

### 8.3 L3 (MySQL) 故障

- **影响**: 持久化存储失效，新数据无法写入
- **恢复**: 需要手动恢复 MySQL
- **注意**: L1/L2 中的数据仍可访问

---

## 9. 监控指标

建议监控以下指标：

| 指标 | 说明 |
|------|------|
| cache_hit_total | 各层缓存命中次数 |
| cache_miss_total | 各层缓存未命中次数 |
| cache_hit_rate | 缓存命中率 |
| cache_latency | 缓存访问延迟 |
| backfill_queue_size | 回填队列大小 |
| backfill_total | 回填次数 |

---

## 10. 总结

本项目的三级缓存设计具有以下优势：

1. **高性能**: 本地缓存提供微秒级访问
2. **高可用**: 多级缓存保证服务可用性
3. **数据持久化**: MySQL 保证数据不丢失
4. **自动回填**: 缓存未命中后自动回填上层
5. **可扩展**: 支持添加更多缓存层级

通过合理配置各层缓存参数，可以在性能和成本之间取得最佳平衡。
